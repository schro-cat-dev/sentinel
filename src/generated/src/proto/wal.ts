// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.0
//   protoc               v6.33.0
// source: src/proto/wal.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "wal";

/** メインのエントリポイント */
export interface WalEntry {
  /** WAL メタデータ */
  sequenceId: bigint;
  prevHash: string;
  /** Log 共通フィールド */
  traceId: string;
  spanId?: string | undefined;
  parentSpanId?: string | undefined;
  actorId?:
    | string
    | undefined;
  /** LogType (string) */
  type: string;
  /** LogLevel (number) */
  level: number;
  timestamp: string;
  logicalClock: number;
  boundary: string;
  serviceId: string;
  /** "SYSTEM" | "AI_AGENT" */
  origin: string;
  isCritical: boolean;
  /** AI Context (Nested) */
  aiContext?: AiContext | undefined;
  message: string;
  /** JSONValue -> stringified */
  inputJson?: string | undefined;
  traceInfo?: string | undefined;
  triggerAgent: boolean;
  agentBackLog?: AgentBacklog | undefined;
  details?: string | undefined;
  tags: LogTag[];
  resourceIds: string[];
  /** Log interface's previousHash */
  previousHash?: string | undefined;
  hash?: string | undefined;
  signature?: string | undefined;
}

export interface AiContext {
  agentId: string;
  taskId: string;
  loopDepth: number;
}

export interface LogTag {
  key: string;
  category: string;
}

export interface AgentBacklog {
  agentId: string;
  taskId: string;
  actionType: string;
  model: string;
  inputHash: string;
  /** unknown -> stringified */
  outputJson?: string | undefined;
  isAsynchronous: boolean;
  generatedAt: string;
  triggeredAt?: string | undefined;
  processorInfo?: ProcessorInfo | undefined;
  confidence?:
    | number
    | undefined;
  /** "pending" | "success" | "failed" */
  status: string;
  error?: string | undefined;
}

export interface ProcessorInfo {
  resourceInfo?: ResourceInfo | undefined;
}

export interface ResourceInfo {
  cpu?: HardwareInfo | undefined;
  memory?: HardwareInfo | undefined;
  outerStorage?: HardwareInfo | undefined;
  serviceInfo?: ServiceInfo | undefined;
}

export interface HardwareInfo {
  quantity: number;
  unit: string;
}

export interface ServiceInfo {
  serviceId: string;
  instanceId: string;
  version: string;
  deployment: string;
  diContainerRuntime?: string | undefined;
}

function createBaseWalEntry(): WalEntry {
  return {
    sequenceId: 0n,
    prevHash: "",
    traceId: "",
    spanId: undefined,
    parentSpanId: undefined,
    actorId: undefined,
    type: "",
    level: 0,
    timestamp: "",
    logicalClock: 0,
    boundary: "",
    serviceId: "",
    origin: "",
    isCritical: false,
    aiContext: undefined,
    message: "",
    inputJson: undefined,
    traceInfo: undefined,
    triggerAgent: false,
    agentBackLog: undefined,
    details: undefined,
    tags: [],
    resourceIds: [],
    previousHash: undefined,
    hash: undefined,
    signature: undefined,
  };
}

export const WalEntry: MessageFns<WalEntry> = {
  encode(message: WalEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sequenceId !== 0n) {
      if (BigInt.asUintN(64, message.sequenceId) !== message.sequenceId) {
        throw new globalThis.Error("value provided for field message.sequenceId of type uint64 too large");
      }
      writer.uint32(8).uint64(message.sequenceId);
    }
    if (message.prevHash !== "") {
      writer.uint32(18).string(message.prevHash);
    }
    if (message.traceId !== "") {
      writer.uint32(26).string(message.traceId);
    }
    if (message.spanId !== undefined) {
      writer.uint32(34).string(message.spanId);
    }
    if (message.parentSpanId !== undefined) {
      writer.uint32(42).string(message.parentSpanId);
    }
    if (message.actorId !== undefined) {
      writer.uint32(50).string(message.actorId);
    }
    if (message.type !== "") {
      writer.uint32(58).string(message.type);
    }
    if (message.level !== 0) {
      writer.uint32(64).uint32(message.level);
    }
    if (message.timestamp !== "") {
      writer.uint32(74).string(message.timestamp);
    }
    if (message.logicalClock !== 0) {
      writer.uint32(81).double(message.logicalClock);
    }
    if (message.boundary !== "") {
      writer.uint32(90).string(message.boundary);
    }
    if (message.serviceId !== "") {
      writer.uint32(98).string(message.serviceId);
    }
    if (message.origin !== "") {
      writer.uint32(106).string(message.origin);
    }
    if (message.isCritical !== false) {
      writer.uint32(112).bool(message.isCritical);
    }
    if (message.aiContext !== undefined) {
      AiContext.encode(message.aiContext, writer.uint32(122).fork()).join();
    }
    if (message.message !== "") {
      writer.uint32(130).string(message.message);
    }
    if (message.inputJson !== undefined) {
      writer.uint32(138).string(message.inputJson);
    }
    if (message.traceInfo !== undefined) {
      writer.uint32(146).string(message.traceInfo);
    }
    if (message.triggerAgent !== false) {
      writer.uint32(152).bool(message.triggerAgent);
    }
    if (message.agentBackLog !== undefined) {
      AgentBacklog.encode(message.agentBackLog, writer.uint32(162).fork()).join();
    }
    if (message.details !== undefined) {
      writer.uint32(170).string(message.details);
    }
    for (const v of message.tags) {
      LogTag.encode(v!, writer.uint32(178).fork()).join();
    }
    for (const v of message.resourceIds) {
      writer.uint32(186).string(v!);
    }
    if (message.previousHash !== undefined) {
      writer.uint32(194).string(message.previousHash);
    }
    if (message.hash !== undefined) {
      writer.uint32(202).string(message.hash);
    }
    if (message.signature !== undefined) {
      writer.uint32(210).string(message.signature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WalEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWalEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.sequenceId = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.prevHash = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.traceId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.spanId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.parentSpanId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.actorId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.level = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 81) {
            break;
          }

          message.logicalClock = reader.double();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.boundary = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.serviceId = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.origin = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.isCritical = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.aiContext = AiContext.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.inputJson = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.traceInfo = reader.string();
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.triggerAgent = reader.bool();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.agentBackLog = AgentBacklog.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.details = reader.string();
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.tags.push(LogTag.decode(reader, reader.uint32()));
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.resourceIds.push(reader.string());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.previousHash = reader.string();
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.hash = reader.string();
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.signature = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<WalEntry>, I>>(base?: I): WalEntry {
    return WalEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WalEntry>, I>>(object: I): WalEntry {
    const message = createBaseWalEntry();
    message.sequenceId = object.sequenceId ?? 0n;
    message.prevHash = object.prevHash ?? "";
    message.traceId = object.traceId ?? "";
    message.spanId = object.spanId ?? undefined;
    message.parentSpanId = object.parentSpanId ?? undefined;
    message.actorId = object.actorId ?? undefined;
    message.type = object.type ?? "";
    message.level = object.level ?? 0;
    message.timestamp = object.timestamp ?? "";
    message.logicalClock = object.logicalClock ?? 0;
    message.boundary = object.boundary ?? "";
    message.serviceId = object.serviceId ?? "";
    message.origin = object.origin ?? "";
    message.isCritical = object.isCritical ?? false;
    message.aiContext = (object.aiContext !== undefined && object.aiContext !== null)
      ? AiContext.fromPartial(object.aiContext)
      : undefined;
    message.message = object.message ?? "";
    message.inputJson = object.inputJson ?? undefined;
    message.traceInfo = object.traceInfo ?? undefined;
    message.triggerAgent = object.triggerAgent ?? false;
    message.agentBackLog = (object.agentBackLog !== undefined && object.agentBackLog !== null)
      ? AgentBacklog.fromPartial(object.agentBackLog)
      : undefined;
    message.details = object.details ?? undefined;
    message.tags = object.tags?.map((e) => LogTag.fromPartial(e)) || [];
    message.resourceIds = object.resourceIds?.map((e) => e) || [];
    message.previousHash = object.previousHash ?? undefined;
    message.hash = object.hash ?? undefined;
    message.signature = object.signature ?? undefined;
    return message;
  },
};

function createBaseAiContext(): AiContext {
  return { agentId: "", taskId: "", loopDepth: 0 };
}

export const AiContext: MessageFns<AiContext> = {
  encode(message: AiContext, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.agentId !== "") {
      writer.uint32(10).string(message.agentId);
    }
    if (message.taskId !== "") {
      writer.uint32(18).string(message.taskId);
    }
    if (message.loopDepth !== 0) {
      writer.uint32(25).double(message.loopDepth);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AiContext {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAiContext();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.agentId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.taskId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.loopDepth = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<AiContext>, I>>(base?: I): AiContext {
    return AiContext.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AiContext>, I>>(object: I): AiContext {
    const message = createBaseAiContext();
    message.agentId = object.agentId ?? "";
    message.taskId = object.taskId ?? "";
    message.loopDepth = object.loopDepth ?? 0;
    return message;
  },
};

function createBaseLogTag(): LogTag {
  return { key: "", category: "" };
}

export const LogTag: MessageFns<LogTag> = {
  encode(message: LogTag, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.category !== "") {
      writer.uint32(18).string(message.category);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogTag {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogTag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.category = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<LogTag>, I>>(base?: I): LogTag {
    return LogTag.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LogTag>, I>>(object: I): LogTag {
    const message = createBaseLogTag();
    message.key = object.key ?? "";
    message.category = object.category ?? "";
    return message;
  },
};

function createBaseAgentBacklog(): AgentBacklog {
  return {
    agentId: "",
    taskId: "",
    actionType: "",
    model: "",
    inputHash: "",
    outputJson: undefined,
    isAsynchronous: false,
    generatedAt: "",
    triggeredAt: undefined,
    processorInfo: undefined,
    confidence: undefined,
    status: "",
    error: undefined,
  };
}

export const AgentBacklog: MessageFns<AgentBacklog> = {
  encode(message: AgentBacklog, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.agentId !== "") {
      writer.uint32(10).string(message.agentId);
    }
    if (message.taskId !== "") {
      writer.uint32(18).string(message.taskId);
    }
    if (message.actionType !== "") {
      writer.uint32(26).string(message.actionType);
    }
    if (message.model !== "") {
      writer.uint32(34).string(message.model);
    }
    if (message.inputHash !== "") {
      writer.uint32(42).string(message.inputHash);
    }
    if (message.outputJson !== undefined) {
      writer.uint32(50).string(message.outputJson);
    }
    if (message.isAsynchronous !== false) {
      writer.uint32(56).bool(message.isAsynchronous);
    }
    if (message.generatedAt !== "") {
      writer.uint32(66).string(message.generatedAt);
    }
    if (message.triggeredAt !== undefined) {
      writer.uint32(74).string(message.triggeredAt);
    }
    if (message.processorInfo !== undefined) {
      ProcessorInfo.encode(message.processorInfo, writer.uint32(82).fork()).join();
    }
    if (message.confidence !== undefined) {
      writer.uint32(89).double(message.confidence);
    }
    if (message.status !== "") {
      writer.uint32(98).string(message.status);
    }
    if (message.error !== undefined) {
      writer.uint32(106).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AgentBacklog {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgentBacklog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.agentId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.taskId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.actionType = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.model = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.inputHash = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.outputJson = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.isAsynchronous = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.generatedAt = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.triggeredAt = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.processorInfo = ProcessorInfo.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 89) {
            break;
          }

          message.confidence = reader.double();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<AgentBacklog>, I>>(base?: I): AgentBacklog {
    return AgentBacklog.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AgentBacklog>, I>>(object: I): AgentBacklog {
    const message = createBaseAgentBacklog();
    message.agentId = object.agentId ?? "";
    message.taskId = object.taskId ?? "";
    message.actionType = object.actionType ?? "";
    message.model = object.model ?? "";
    message.inputHash = object.inputHash ?? "";
    message.outputJson = object.outputJson ?? undefined;
    message.isAsynchronous = object.isAsynchronous ?? false;
    message.generatedAt = object.generatedAt ?? "";
    message.triggeredAt = object.triggeredAt ?? undefined;
    message.processorInfo = (object.processorInfo !== undefined && object.processorInfo !== null)
      ? ProcessorInfo.fromPartial(object.processorInfo)
      : undefined;
    message.confidence = object.confidence ?? undefined;
    message.status = object.status ?? "";
    message.error = object.error ?? undefined;
    return message;
  },
};

function createBaseProcessorInfo(): ProcessorInfo {
  return { resourceInfo: undefined };
}

export const ProcessorInfo: MessageFns<ProcessorInfo> = {
  encode(message: ProcessorInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resourceInfo !== undefined) {
      ResourceInfo.encode(message.resourceInfo, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessorInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessorInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.resourceInfo = ResourceInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<ProcessorInfo>, I>>(base?: I): ProcessorInfo {
    return ProcessorInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessorInfo>, I>>(object: I): ProcessorInfo {
    const message = createBaseProcessorInfo();
    message.resourceInfo = (object.resourceInfo !== undefined && object.resourceInfo !== null)
      ? ResourceInfo.fromPartial(object.resourceInfo)
      : undefined;
    return message;
  },
};

function createBaseResourceInfo(): ResourceInfo {
  return { cpu: undefined, memory: undefined, outerStorage: undefined, serviceInfo: undefined };
}

export const ResourceInfo: MessageFns<ResourceInfo> = {
  encode(message: ResourceInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cpu !== undefined) {
      HardwareInfo.encode(message.cpu, writer.uint32(10).fork()).join();
    }
    if (message.memory !== undefined) {
      HardwareInfo.encode(message.memory, writer.uint32(18).fork()).join();
    }
    if (message.outerStorage !== undefined) {
      HardwareInfo.encode(message.outerStorage, writer.uint32(26).fork()).join();
    }
    if (message.serviceInfo !== undefined) {
      ServiceInfo.encode(message.serviceInfo, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResourceInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cpu = HardwareInfo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.memory = HardwareInfo.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.outerStorage = HardwareInfo.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.serviceInfo = ServiceInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<ResourceInfo>, I>>(base?: I): ResourceInfo {
    return ResourceInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResourceInfo>, I>>(object: I): ResourceInfo {
    const message = createBaseResourceInfo();
    message.cpu = (object.cpu !== undefined && object.cpu !== null) ? HardwareInfo.fromPartial(object.cpu) : undefined;
    message.memory = (object.memory !== undefined && object.memory !== null)
      ? HardwareInfo.fromPartial(object.memory)
      : undefined;
    message.outerStorage = (object.outerStorage !== undefined && object.outerStorage !== null)
      ? HardwareInfo.fromPartial(object.outerStorage)
      : undefined;
    message.serviceInfo = (object.serviceInfo !== undefined && object.serviceInfo !== null)
      ? ServiceInfo.fromPartial(object.serviceInfo)
      : undefined;
    return message;
  },
};

function createBaseHardwareInfo(): HardwareInfo {
  return { quantity: 0, unit: "" };
}

export const HardwareInfo: MessageFns<HardwareInfo> = {
  encode(message: HardwareInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.quantity !== 0) {
      writer.uint32(9).double(message.quantity);
    }
    if (message.unit !== "") {
      writer.uint32(18).string(message.unit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HardwareInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHardwareInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.quantity = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.unit = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<HardwareInfo>, I>>(base?: I): HardwareInfo {
    return HardwareInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HardwareInfo>, I>>(object: I): HardwareInfo {
    const message = createBaseHardwareInfo();
    message.quantity = object.quantity ?? 0;
    message.unit = object.unit ?? "";
    return message;
  },
};

function createBaseServiceInfo(): ServiceInfo {
  return { serviceId: "", instanceId: "", version: "", deployment: "", diContainerRuntime: undefined };
}

export const ServiceInfo: MessageFns<ServiceInfo> = {
  encode(message: ServiceInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceId !== "") {
      writer.uint32(10).string(message.serviceId);
    }
    if (message.instanceId !== "") {
      writer.uint32(18).string(message.instanceId);
    }
    if (message.version !== "") {
      writer.uint32(26).string(message.version);
    }
    if (message.deployment !== "") {
      writer.uint32(34).string(message.deployment);
    }
    if (message.diContainerRuntime !== undefined) {
      writer.uint32(42).string(message.diContainerRuntime);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.serviceId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.instanceId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.deployment = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.diContainerRuntime = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<ServiceInfo>, I>>(base?: I): ServiceInfo {
    return ServiceInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServiceInfo>, I>>(object: I): ServiceInfo {
    const message = createBaseServiceInfo();
    message.serviceId = object.serviceId ?? "";
    message.instanceId = object.instanceId ?? "";
    message.version = object.version ?? "";
    message.deployment = object.deployment ?? "";
    message.diContainerRuntime = object.diContainerRuntime ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
